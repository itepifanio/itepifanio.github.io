<!DOCTYPE html>
<html lang="pt"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Carregamento lento com scroll horizontal | Bloguito</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Carregamento lento com scroll horizontal" />
<meta property="og:locale" content="pt" />
<meta name="description" content="Recentemente me deparei com o seguinte cenário: um sistema de gerenciamentos de fluxos de trabalho que permite configuração de kanbans, como o da imagem abaixo, sendo que um usuário em particular configurou seu kanban com 38 colunas." />
<meta property="og:description" content="Recentemente me deparei com o seguinte cenário: um sistema de gerenciamentos de fluxos de trabalho que permite configuração de kanbans, como o da imagem abaixo, sendo que um usuário em particular configurou seu kanban com 38 colunas." />
<link rel="canonical" href="https://itepifanio.github.io//pt/2021/10/23/carregamento-lento-scroll-horizontal.html" />
<meta property="og:url" content="https://itepifanio.github.io//pt/2021/10/23/carregamento-lento-scroll-horizontal.html" />
<meta property="og:site_name" content="Bloguito" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-23T20:09:20+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Carregamento lento com scroll horizontal" />
<script type="application/ld+json">
{"description":"Recentemente me deparei com o seguinte cenário: um sistema de gerenciamentos de fluxos de trabalho que permite configuração de kanbans, como o da imagem abaixo, sendo que um usuário em particular configurou seu kanban com 38 colunas.","headline":"Carregamento lento com scroll horizontal","dateModified":"2021-10-23T20:09:20+00:00","datePublished":"2021-10-23T20:09:20+00:00","url":"https://itepifanio.github.io//pt/2021/10/23/carregamento-lento-scroll-horizontal.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://itepifanio.github.io//pt/2021/10/23/carregamento-lento-scroll-horizontal.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://itepifanio.github.io/feed.xml" title="Bloguito" /><script async src="https://www.googletagmanager.com/gtag/js?id=G-YBQH55JB4K"></script>
<script>
  window['ga-disable-G-YBQH55JB4K'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YBQH55JB4K');
</script>

<script defer data-domain="itepifanio.github.io" src="https://plausible.io/js/plausible.js"></script>
</head>
<body><header class="site-header">
    <div class="wrapper"><a class="site-title" rel="author" href="/">Bloguito</a>

        <nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger" />
            <label for="nav-trigger">
                <span class="menu-icon">
                    <svg viewBox="0 0 18 15" width="18px" height="15px">
                        <path
                            d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
                    </svg>
                </span>
            </label>

            <div class="trigger">
                
                    <a class="page-link" href="/pt/about">Sobre</a>
                

                
                    <a class="link-en" href="/">En</a>
                

                
                    <a class="link-it" href="/pt/"><u>PT-br</u></a>
                                
            </div>
        </nav>
    </div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" style="text-align: justify;" itemscope>

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Carregamento lento com scroll horizontal</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-10-23T20:09:20+00:00" itemprop="datePublished">
        Oct 23, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Recentemente me deparei com o seguinte cenário: um sistema de gerenciamentos de fluxos de trabalho que permite configuração  de kanbans, como o da imagem abaixo, sendo que um usuário em particular configurou seu kanban com 38 colunas.</p>

<p>Cada coluna do kanban realizava uma requisição e do jeito que o sistema tinha sido desenvolvido gerava-se 38 requisições assim que a página era carregada, o que acabava espancando o banco de dados e o servidor.</p>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6ui3slceaoxqovpxm1uo.jpg" alt="Ilustração de um kanban com cinco colunas na sequência: stories, todo, in progress, testing, done" /></p>

<p>Inicialmente precisavamos diminuir a quantidade de requisições, limitando apenas aos cards visíveis na tela do usuário. Depois precisavamos fazer com que, caso o usuário rolasse para o fim da página de uma vez, as colunas que ficaram visíveis não carregassem a menos que estivessem a um certo tempo visíveis.</p>

<h2 id="limitando-o-carregamento-aos-cards-visíveis">Limitando o carregamento aos cards visíveis</h2>

<p>O javascript oferece uma API chamada <a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver">IntersectionObserver</a> que permite monitorar elementos HTML e verificar sua visibilidade na tela. O código abaixo mostra o funcionamento mais básico dela.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">onIntersection</span> <span class="o">=</span> <span class="p">(</span><span class="nx">elements</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">elements</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">element</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">isIntersecting</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="dl">'</span><span class="s1">is visible</span><span class="dl">'</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">IntersectionObserver</span><span class="p">(</span><span class="nx">onIntersection</span><span class="p">);</span>

<span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.my-elements</span><span class="dl">'</span><span class="p">));</span>
</code></pre></div></div>

<p>A função <code class="language-plaintext highlighter-rouge">onIntersection</code> é responsável pela lógica que será aplicada aos elementos visiveis, ela recebe uma lista de elementos e verifica que se forem visiveis (<code class="language-plaintext highlighter-rouge"> element.isIntersecting </code>) então algo será feito, nesse caso uma mensagem no console é exibida.</p>

<p>A chamada da API ` IntersectionObserver ` é feita e atribuida a variável ` observer <code class="language-plaintext highlighter-rouge">. O objeto </code> observer ` conseguirá a partir dali observar elementos no HTML e executar uma lógica somente quando eles forem visíveis na tela do usuário. No meu caso, do kanban gigante, isso foi suficiente para limitar as 38 requisições assim que a página carregava para apenas 5, mas caso o usuário rolasse a página rapidamente várias requisições seriam feitas, ou seja, se eu fosse até o fim da página de uma vez as outras 33 requisições seriam chamadas também de uma vez só.</p>

<h2 id="carregamento-apenas-após-certo-tempo-do-elemento-visível-na-página">Carregamento apenas após certo tempo do elemento visível na página</h2>

<p>A API ` IntersectionObserver ` tem uma <a href="https://web.dev/intersectionobserver-v2/">versão 2</a> que permite a captura de quanto tempo um certo elemento HTML ficou visível na tela e isso resolveria facilmente o problema de carregar o elemento HTML apenas depois de certo tempo. Entretanto, a versão 2 ainda não tem suas implementações compativeis com a maioria dos navegadores.</p>

<p>No meu caso específico eu estava utilizando um componente pai que renderizava os 38 elementos filhos e eu não conseguia verificar quando esses 38 elementos filhos terminaram de ser renderizados para observa-los com o ` InsertersectionObserver `, então controlar o tempo que cada elemento ficou visível na tela ficou um pouco mais complicado.</p>

<p>Cada um dos 38 elementos filhos sabiam quando eles mesmos eram renderizados, então conseguia-se utilizar a ` IntersectionObserver ` internamente em cada um deles. Utilizando a função ` setTimeout ` do javascript consegue-se observação o elemento após um certo tempo especificado em milisegundos.</p>

<p>Temos 38 elementos ao todo, só que a maioria não é visível na tela e se torna visível ao scrollar, com o delay do ` setTimeout ` essa ação leva ainda algum tempo a ser executada. Durante o scroll, quando o elemento visível na tela ainda não disparou o <code class="language-plaintext highlighter-rouge">setTimeout</code> especificado e o usuário já scrollou para um elemento seguinte consegue-se remover o timeout do elemento anterior da pilha de execução e então carregar somente o elemento seguinte. O código a seguir mostra essa estratégia.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">border border-black m-1 p-10 min-w-max h-10</span><span class="dl">"</span>
       <span class="nx">x</span><span class="o">-</span><span class="nx">data</span><span class="o">=</span><span class="dl">""</span>
       <span class="nx">x</span><span class="o">-</span><span class="nx">init</span><span class="o">=</span><span class="dl">"</span><span class="s2">() =&gt; {
           let timeout;
           let loadColumn = function (elements) {
               clearTimeout(timeout);
               
               timeout = setTimeout(function() {
                   elements.forEach(element =&gt; {
                       if (element.isIntersecting) {
                           // do something
                           observer.unobserve(element.target);
                       }
                   });
               }, 750);
           }
           
           let observer = new IntersectionObserver(loadColumn);
           let target = $el;
           observer.observe(target);
       }</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div>

<p>Quando o componente é carregado na página ele já começa a observar a si mesmo utilizando a função ` loadColumn `. Tal função remove os timeouts anteriores (que não foram acionados) da pilha de execução e adiciona um novo timeout que após 750 milisegundos faz algo e remove a observação para não refazer a mesma lógica se o elemento se tornar visível novamente.</p>

<p>No meu caso a lógica era a requisição para o servidor então eu só precisava carregar o dado uma vez e depois ignorar se o elemento ficasse visível novamente na página, por isso ele remove a própria observação.</p>

<p>Achou a sintaxe do código acima estranha? Esse microframework javascript se chama <a href="https://alpinejs.dev/">AlpineJS</a> e foi o que utilizei para desenvolver a solução completa. Uma POC mais simples, sem a requisição pro servidor, pode ser vista logo abaixo. Após ficar visível na sua tela os quadrados brancos se tornarão pretos indicando a requisição pro servidor.</p>

<p data-height="400" data-theme-id="0" data-slug-hash="PoKqGPm" data-default-tab="result" data-user="" class="codepen">See the Pen <a href="http://codepen.io//pen/PoKqGPm/">Carregamento lento com scroll horizontal</a> by  (<a href="http://codepen.io/">@</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async="" src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>Caso se interesse por ver uma solução com vanilla javascript  a minha referência <a href="https://www.codeguage.com/tutorials/lazy-loading/intersection-observer">foi essa</a>.</p>


  </div><a class="u-url" href="//pt/2021/10/23/carregamento-lento-scroll-horizontal.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/%20/"></data>

    <div class="wrapper">
        <div class="footer-col-wrapper">
            <div class="footer-col">
                <p class="feed-subscribe">
                    <a href="/feed.xml">
                        <svg class="svg-icon orange">
                            <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
                        </svg><span>Subscribe</span>
                    </a>
                </p>
            </div>
            <div class="footer-col">
                <p>Web dev &amp; more.</p>
            </div>
        </div>

        <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/itepifanio"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">itepifanio</span></a></li><li><a href="https://www.twitter.com/itepifanio"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">itepifanio</span></a></li></ul>
</div>
    </div>
</footer></body>

</html>